{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Broadworks OCI-P Interface broadworks_ocip interfaces to the OCI-P provisioning interface of a Broadworks softswitch Free software: BSD license Documentation: https://nigelm.github.io/broadworks_ocip/ Features python objects to match all Broadworks schema objects API framework to talk to a Broadworks server additional magic to handle authentication and sessions Based on Broadworks schema R21 Installation With pip : python3.6 -m pip install ssh2_parse_key Usage More details is given within the usage section of the documentation, but the minimal summary is:- from broadworks_ocip import BroadworksAPI # configure the API, connect and authenticate to the server api = BroadworksAPI ( host = args . host , port = args . port , username = args . username , password = args . password , ) # get the platform software level response = api . command ( \"SystemSoftwareVersionGetRequest\" ) print ( response . version ) Credits The class is built using Michael DeHaan's ClassForge object system. Development on the python version was done by Nigel Metheringham <nigelm@cpan.org>","title":"Overview"},{"location":"#broadworks-oci-p-interface","text":"broadworks_ocip interfaces to the OCI-P provisioning interface of a Broadworks softswitch Free software: BSD license Documentation: https://nigelm.github.io/broadworks_ocip/","title":"Broadworks OCI-P Interface"},{"location":"#features","text":"python objects to match all Broadworks schema objects API framework to talk to a Broadworks server additional magic to handle authentication and sessions Based on Broadworks schema R21","title":"Features"},{"location":"#installation","text":"With pip : python3.6 -m pip install ssh2_parse_key","title":"Installation"},{"location":"#usage","text":"More details is given within the usage section of the documentation, but the minimal summary is:- from broadworks_ocip import BroadworksAPI # configure the API, connect and authenticate to the server api = BroadworksAPI ( host = args . host , port = args . port , username = args . username , password = args . password , ) # get the platform software level response = api . command ( \"SystemSoftwareVersionGetRequest\" ) print ( response . version )","title":"Usage"},{"location":"#credits","text":"The class is built using Michael DeHaan's ClassForge object system. Development on the python version was done by Nigel Metheringham <nigelm@cpan.org>","title":"Credits"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . [1.0.1] - 2020-10-15 Reworked ElementInfo into attrs based class Various improvements to schema parsing into classes Session Id is no longer hidden on command classes Additional how/why documentation Converted to use poetry for development management [0.5.3] - 2020-10-07 Occaisionally you can get an exception thrown on socket close as the api object is deleted. Added try/except around this to catch. More log modifications - less opinionated Split traffic logging to a VERBOSE_DEBUG setting - log level 9 [0.5.2] - 2020-10-07 Logging was on at debug level by default - switched to WARNING level. [0.5.1] - 2020-10-06 Removed a development debug print which had managed to stay hidden... [0.5.0] - 2020-10-06 Reversed the stupid mistake of trying to special case complex types such as UnboundedPositiveInt - these now need to be treated as the complex types they are. [0.4.0] - 2020-10-06 Split out handling in API of Types and Commands. This changes get_command_class() to get_type_class() and adds get_type_object() [0.3.1] - 2020-10-05 Fixed error where exception thrown as tests cleaned up. [0.3.0] - 2020-10-01 Support for lists in XML generation Support for XSD choice elements - handled by making them optional Handling of embedded types in XML generation Start of special casing some base types - ie UnboundedPositiveInt [0.2.0] - 2020-09-30 Support for list returns - eg ServiceProviderServicePackGetListResponse [0.1.0] - 2020-09-30 First release but not on PyPI. Patch releases on Pypi after automation sorted.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#101-2020-10-15","text":"Reworked ElementInfo into attrs based class Various improvements to schema parsing into classes Session Id is no longer hidden on command classes Additional how/why documentation Converted to use poetry for development management","title":"[1.0.1] - 2020-10-15"},{"location":"changelog/#053-2020-10-07","text":"Occaisionally you can get an exception thrown on socket close as the api object is deleted. Added try/except around this to catch. More log modifications - less opinionated Split traffic logging to a VERBOSE_DEBUG setting - log level 9","title":"[0.5.3] - 2020-10-07"},{"location":"changelog/#052-2020-10-07","text":"Logging was on at debug level by default - switched to WARNING level.","title":"[0.5.2] - 2020-10-07"},{"location":"changelog/#051-2020-10-06","text":"Removed a development debug print which had managed to stay hidden...","title":"[0.5.1] - 2020-10-06"},{"location":"changelog/#050-2020-10-06","text":"Reversed the stupid mistake of trying to special case complex types such as UnboundedPositiveInt - these now need to be treated as the complex types they are.","title":"[0.5.0] - 2020-10-06"},{"location":"changelog/#040-2020-10-06","text":"Split out handling in API of Types and Commands. This changes get_command_class() to get_type_class() and adds get_type_object()","title":"[0.4.0] - 2020-10-06"},{"location":"changelog/#031-2020-10-05","text":"Fixed error where exception thrown as tests cleaned up.","title":"[0.3.1] - 2020-10-05"},{"location":"changelog/#030-2020-10-01","text":"Support for lists in XML generation Support for XSD choice elements - handled by making them optional Handling of embedded types in XML generation Start of special casing some base types - ie UnboundedPositiveInt","title":"[0.3.0] - 2020-10-01"},{"location":"changelog/#020-2020-09-30","text":"Support for list returns - eg ServiceProviderServicePackGetListResponse","title":"[0.2.0] - 2020-09-30"},{"location":"changelog/#010-2020-09-30","text":"First release but not on PyPI. Patch releases on Pypi after automation sorted.","title":"[0.1.0] - 2020-09-30"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Report Bugs Report bugs at https://github.com/nigelm/broadworks_ocip/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation broadworks_ocip could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback The best way to send feedback is to file an issue at https://github.com/nigelm/broadworks_ocip/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up broadworks_ocip for local development. Fork the broadworks_ocip repo on GitHub. Clone your fork locally: $ git clone git@github.com:your_name_here/broadworks_ocip.git We use poetry for development, this is how you set up your fork for local development $ cd broadworks_ocip/ $ poetry install Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, use pre-commit to do basic checks and ensure formatting is consitant, and check that your changes pass the tests:: $ pre-commit run $ poetry run pytest $ poetry run make docs # generate local docs for checking pre-commit may need to be installed onto your system. Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Deploying A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md ). Then run: $ bump2version patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/nigelm/broadworks_ocip/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"broadworks_ocip could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/nigelm/broadworks_ocip/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up broadworks_ocip for local development. Fork the broadworks_ocip repo on GitHub. Clone your fork locally: $ git clone git@github.com:your_name_here/broadworks_ocip.git We use poetry for development, this is how you set up your fork for local development $ cd broadworks_ocip/ $ poetry install Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, use pre-commit to do basic checks and ensure formatting is consitant, and check that your changes pass the tests:: $ pre-commit run $ poetry run pytest $ poetry run make docs # generate local docs for checking pre-commit may need to be installed onto your system. Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md ). Then run: $ bump2version patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"internals/","text":"Internal Design The intention was always to have a python class per OCICommand element from the Broadworks AS schema. To make this easier the process_schema.py program was produced to break down the Broadworks schema into its component parts, which are represented as python classes. The classes are broken down into types , requests (commands that are sent to the Broadworks system), and responses (the replies back from the Broadworks system). The classes themselves are described by a tuple of ElementInfo instances - one per property in the schema class, and a class property for each schema property. Naming of these is in the more pythonic snake case rather than the Java-esque CamelCase. The ElementInfo class is used mainly to guide the XML serialisation and deserialisation of each object. They contain the python and XML names of each property and some flags about the propery - for example is this a required element is_required , an array like element is_array , a tabular set of data is_table or a complex element (ie containing sub-elements) is_complex . All of the component classes of the system are intended to be immutable. There are currently no helpers to aid creating a modified instance from an existing instance because these operations do not appear to be part of a normal Broadworks workflow. Implementation The ElementInfo class was originally a named tuple, but this was changed later to an attrs based class for speed and to give some type checking. The generated classes are all based on Michael DeHaan's ClassForge object system. Although it appears that attrs can provide all the functionality these objects need, it became apparent in testing that using attrs based classes added a substantial startup cost to the library, which ClassForge does not. Due to the huge number of component classes, and that they need to have the session id associated with them on creation (since the objects themselves are immutable), the BroadworksAPI class has a set of helper methods to create and send the serialised commands to the server and then return the results. In practice a user only interacts with the BroadworksAPI methods. Problems There is no easy way that I can find - especially when autogenerated - to replicate the XML schema choice elements - effectively a union between different possibilities. As such any element within a choice element has been expressed as a non-required element, and it is up to the library user to apply appropriate values to make the generated XML work. As an example of this, look at the UnboundedPositiveInt elements within the usage example, which may have either a positive numeric quantity value or have unlimited set true. Additionally in the example the surrounding ServicePackAuthorization element may have either unauthorized=True or authorized_quantity set to a UnboundedPositiveInt . The tables returned in many command responses have no type information in the schema as to how to treat them - the column information is also passed within the response itself. This means that often there are boolean or numeric values that are represented as strings. In particular the booleans will have textual values of either true or false - all in lower case.","title":"Internal Design"},{"location":"internals/#internal-design","text":"The intention was always to have a python class per OCICommand element from the Broadworks AS schema. To make this easier the process_schema.py program was produced to break down the Broadworks schema into its component parts, which are represented as python classes. The classes are broken down into types , requests (commands that are sent to the Broadworks system), and responses (the replies back from the Broadworks system). The classes themselves are described by a tuple of ElementInfo instances - one per property in the schema class, and a class property for each schema property. Naming of these is in the more pythonic snake case rather than the Java-esque CamelCase. The ElementInfo class is used mainly to guide the XML serialisation and deserialisation of each object. They contain the python and XML names of each property and some flags about the propery - for example is this a required element is_required , an array like element is_array , a tabular set of data is_table or a complex element (ie containing sub-elements) is_complex . All of the component classes of the system are intended to be immutable. There are currently no helpers to aid creating a modified instance from an existing instance because these operations do not appear to be part of a normal Broadworks workflow.","title":"Internal Design"},{"location":"internals/#implementation","text":"The ElementInfo class was originally a named tuple, but this was changed later to an attrs based class for speed and to give some type checking. The generated classes are all based on Michael DeHaan's ClassForge object system. Although it appears that attrs can provide all the functionality these objects need, it became apparent in testing that using attrs based classes added a substantial startup cost to the library, which ClassForge does not. Due to the huge number of component classes, and that they need to have the session id associated with them on creation (since the objects themselves are immutable), the BroadworksAPI class has a set of helper methods to create and send the serialised commands to the server and then return the results. In practice a user only interacts with the BroadworksAPI methods.","title":"Implementation"},{"location":"internals/#problems","text":"There is no easy way that I can find - especially when autogenerated - to replicate the XML schema choice elements - effectively a union between different possibilities. As such any element within a choice element has been expressed as a non-required element, and it is up to the library user to apply appropriate values to make the generated XML work. As an example of this, look at the UnboundedPositiveInt elements within the usage example, which may have either a positive numeric quantity value or have unlimited set true. Additionally in the example the surrounding ServicePackAuthorization element may have either unauthorized=True or authorized_quantity set to a UnboundedPositiveInt . The tables returned in many command responses have no type information in the schema as to how to treat them - the column information is also passed within the response itself. This means that often there are boolean or numeric values that are represented as strings. In particular the booleans will have textual values of either true or false - all in lower case.","title":"Problems"},{"location":"library/","text":"Library The library is mainly used via the BroadworksAPI class in the api module: Broadworks OCI-P Interface API Class and code Main API interface - this is basically the only consumer visible part BroadworksAPI BroadworksAPI - A class encapsulating the Broadworks OCI-P API authenticate ( self ) Authenticate the connection to the OCI-P server :raises: OCIErrorResponse Source code in broadworks_ocip/api.py def authenticate ( self ): \"\"\" Authenticate the connection to the OCI-P server :raises: OCIErrorResponse \"\"\" self . send_command ( \"AuthenticationRequest\" , user_id = self . username ) resp = self . receive_response () authhash = hashlib . sha1 ( self . password . encode ()) . hexdigest () . lower () signed_password = ( hashlib . md5 ( \":\" . join ([ resp . nonce , authhash ]) . encode ()) . hexdigest () . lower () ) self . send_command ( \"LoginRequest14sp4\" , user_id = self . username , signed_password = signed_password , ) # if this fails to authenticate an ErrorResponse will be returned which forces # an exception to be raised resp = self . receive_response () # if authentication failed this line will never be executed self . authenticated = True build_despatch_table ( self ) Create a despatch table of commands and types used Source code in broadworks_ocip/api.py def build_despatch_table ( self ): \"\"\" Create a despatch table of commands and types used \"\"\" self . logger . debug ( \"Building Broadworks despatch table\" ) despatch_table = {} # deal with all the main request/responses for module in ( broadworks_ocip . responses , broadworks_ocip . requests , broadworks_ocip . types , ): for name , data in inspect . getmembers ( module , inspect . isclass ): if name . startswith ( \"__\" ): continue try : if data . __module__ in ( \"broadworks_ocip.types\" , \"broadworks_ocip.requests\" , \"broadworks_ocip.responses\" , ): despatch_table [ name ] = data except AttributeError : continue # deal with special cases in base for name , data in inspect . getmembers ( broadworks_ocip . base , inspect . isclass ): if name in ( \"SuccessResponse\" , \"ErrorResponse\" ): despatch_table [ name ] = data despatch_table [ \"c:\" + name ] = data # namespace issues # we now have a despatch table... self . _despatch_table = despatch_table self . logger . debug ( \"Built Broadworks despatch table\" ) close ( self , no_log = False ) Close the connection to the OCI-P server Source code in broadworks_ocip/api.py def close ( self , no_log = False ): \"\"\" Close the connection to the OCI-P server \"\"\" if self . authenticated and not no_log : self . logger . debug ( \"Disconnect by logging out\" ) self . send_command ( \"LogoutRequest\" , user_id = self . username , reason = \"Connection close\" , ) self . authenticated = False if self . socket : try : self . socket . shutdown ( socket . SHUT_RDWR ) self . socket . close () except OSError : pass # we just ignore this under these circumstances if not no_log : self . logger . info ( f \"Disconnected from host= { self . host } port= { self . port } \" ) self . socket = None command ( self , command , ** kwargs ) Send a command and parameters to the server, receive and decode a response :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: Object instance :raises: OCIErrorResponse :raises: OCIErrorResponse Source code in broadworks_ocip/api.py def command ( self , command , ** kwargs ): \"\"\" Send a command and parameters to the server, receive and decode a response :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: Object instance :raises: OCIErrorResponse :raises: OCIErrorResponse \"\"\" if not self . authenticated : self . connect () self . authenticate () self . send_command ( command , ** kwargs ) return self . receive_response () configure_logger ( self ) Create and configure a logging object Source code in broadworks_ocip/api.py def configure_logger ( self ): \"\"\" Create and configure a logging object \"\"\" logger = logging . getLogger ( __name__ ) logger . setLevel ( logging . WARNING ) console_handler = logging . StreamHandler ( sys . stdout ) console_handler . setLevel ( logging . WARNING ) logger . addHandler ( console_handler ) self . logger = logger connect ( self ) Open the connection to the OCI-P server :raises: OSError :raises: socket.timeout Source code in broadworks_ocip/api.py def connect ( self ): \"\"\" Open the connection to the OCI-P server :raises: OSError :raises: socket.timeout \"\"\" self . logger . debug ( f \"Attempting connection host= { self . host } port= { self . port } \" ) try : address = ( self . host , self . port ) conn = socket . create_connection ( address = address , timeout = self . connect_timeout , ) self . socket = conn self . logger . info ( f \"Connected to host= { self . host } port= { self . port } \" ) except OSError as e : self . logger . error ( \"Connection failed\" ) raise e except socket . timeout as e : self . logger . error ( \"Connection timed out\" ) raise e decode_xml ( self , xml ) Decode XML into an OCICommand based object instance :param xml:XML string :type command: str :rtype: Object instance Source code in broadworks_ocip/api.py def decode_xml ( self , xml ): \"\"\" Decode XML into an OCICommand based object instance :param xml:XML string :type command: str :rtype: Object instance \"\"\" root = etree . fromstring ( xml ) if root . tag != \" {C} BroadsoftDocument\" : raise ValueError self . logger . debug ( \"Decoding BroadsoftDocument\" ) for element in root : if element . tag == \"command\" : command = element . get ( \"{http://www.w3.org/2001/XMLSchema-instance}type\" ) self . logger . debug ( f \"Decoding command { command } \" ) cls = self . _despatch_table [ command ] result = cls . _build_from_etree ( element ) self . logger . info ( f \"<<< { result . _type } \" ) result . _post_xml_decode () return result get_command_object ( self , command , ** kwargs ) Build the OCICommand object instance for a command and parameter :param command: A single word name of a OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: Object instance Source code in broadworks_ocip/api.py def get_command_object ( self , command , ** kwargs ): \"\"\" Build the OCICommand object instance for a command and parameter :param command: A single word name of a OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: Object instance \"\"\" cls = self . get_type_class ( command ) cmd = cls ( session_id = self . session_id , ** kwargs ) return cmd get_command_xml ( self , command , ** kwargs ) Build the XML for a command and parameter :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: XML string Source code in broadworks_ocip/api.py def get_command_xml ( self , command , ** kwargs ): \"\"\" Build the XML for a command and parameter :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: XML string \"\"\" cmd = self . get_command_object ( command , ** kwargs ) return cmd . _build_xml () get_type_class ( self , command ) Given a name (Request/Response/Type) name, return a class object for it :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :rtype: class object :raises: KeyError Source code in broadworks_ocip/api.py def get_type_class ( self , command ): \"\"\" Given a name (Request/Response/Type) name, return a class object for it :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :rtype: class object :raises: KeyError \"\"\" try : cls = self . _despatch_table [ command ] except KeyError as e : self . logger . error ( f \"Unknown command requested - { command } \" ) raise e return cls get_type_object ( self , command , ** kwargs ) Build the OCIType object instance for a type and parameters :param command: A single word name of a OCIType() :type command: str :param kwargs: The parameters for the command :rtype: Object instance Source code in broadworks_ocip/api.py def get_type_object ( self , command , ** kwargs ): \"\"\" Build the OCIType object instance for a type and parameters :param command: A single word name of a OCIType() :type command: str :param kwargs: The parameters for the command :rtype: Object instance \"\"\" cls = self . get_type_class ( command ) cmd = cls ( ** kwargs ) return cmd on_init ( self ) Initialise the API object Source code in broadworks_ocip/api.py def on_init ( self ): \"\"\" Initialise the API object \"\"\" if self . session_id is None : self . session_id = str ( uuid . uuid4 ()) if self . logger is None : self . configure_logger () self . build_despatch_table () self . authenticated = False receive_response ( self ) Wait and receive response XML from server, and decode it :rtype: Object instance :raises: OCIErrorTimeOut Source code in broadworks_ocip/api.py def receive_response ( self ): \"\"\" Wait and receive response XML from server, and decode it :rtype: Object instance :raises: OCIErrorTimeOut \"\"\" content = b \"\" while True : readable , writable , exceptional = select . select ( [ self . socket ], [], [], self . command_timeout , ) if readable : # there is only one thing in the set... content += self . socket . recv ( 4096 ) # look for the end of document marker (we ignore line ends) splits = content . partition ( b \"</BroadsoftDocument>\" ) if len ( splits [ 1 ]) > 0 : break elif not readable and not writable and not exceptional : raise OCIErrorTimeOut ( object = self , message = \"Read timeout\" ) self . logger . log ( VERBOSE_DEBUG , f \"RECV: { str ( content ) } \" ) return self . decode_xml ( content ) send_command ( self , command , ** kwargs ) Build the XML for a command and parameter and send it to the server :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command Source code in broadworks_ocip/api.py def send_command ( self , command , ** kwargs ): \"\"\" Build the XML for a command and parameter and send it to the server :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command \"\"\" self . logger . info ( f \">>> { command } \" ) xml = self . get_command_xml ( command , ** kwargs ) self . logger . log ( VERBOSE_DEBUG , f \"SEND: { str ( xml ) } \" ) self . socket . sendall ( xml + b \" \\n \" )","title":"API Reference"},{"location":"library/#library","text":"The library is mainly used via the BroadworksAPI class in the api module:","title":"Library"},{"location":"library/#broadworks_ocip.api","text":"Broadworks OCI-P Interface API Class and code Main API interface - this is basically the only consumer visible part","title":"broadworks_ocip.api"},{"location":"library/#broadworks_ocip.api.BroadworksAPI","text":"BroadworksAPI - A class encapsulating the Broadworks OCI-P API","title":"BroadworksAPI"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.authenticate","text":"Authenticate the connection to the OCI-P server :raises: OCIErrorResponse Source code in broadworks_ocip/api.py def authenticate ( self ): \"\"\" Authenticate the connection to the OCI-P server :raises: OCIErrorResponse \"\"\" self . send_command ( \"AuthenticationRequest\" , user_id = self . username ) resp = self . receive_response () authhash = hashlib . sha1 ( self . password . encode ()) . hexdigest () . lower () signed_password = ( hashlib . md5 ( \":\" . join ([ resp . nonce , authhash ]) . encode ()) . hexdigest () . lower () ) self . send_command ( \"LoginRequest14sp4\" , user_id = self . username , signed_password = signed_password , ) # if this fails to authenticate an ErrorResponse will be returned which forces # an exception to be raised resp = self . receive_response () # if authentication failed this line will never be executed self . authenticated = True","title":"authenticate()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.build_despatch_table","text":"Create a despatch table of commands and types used Source code in broadworks_ocip/api.py def build_despatch_table ( self ): \"\"\" Create a despatch table of commands and types used \"\"\" self . logger . debug ( \"Building Broadworks despatch table\" ) despatch_table = {} # deal with all the main request/responses for module in ( broadworks_ocip . responses , broadworks_ocip . requests , broadworks_ocip . types , ): for name , data in inspect . getmembers ( module , inspect . isclass ): if name . startswith ( \"__\" ): continue try : if data . __module__ in ( \"broadworks_ocip.types\" , \"broadworks_ocip.requests\" , \"broadworks_ocip.responses\" , ): despatch_table [ name ] = data except AttributeError : continue # deal with special cases in base for name , data in inspect . getmembers ( broadworks_ocip . base , inspect . isclass ): if name in ( \"SuccessResponse\" , \"ErrorResponse\" ): despatch_table [ name ] = data despatch_table [ \"c:\" + name ] = data # namespace issues # we now have a despatch table... self . _despatch_table = despatch_table self . logger . debug ( \"Built Broadworks despatch table\" )","title":"build_despatch_table()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.close","text":"Close the connection to the OCI-P server Source code in broadworks_ocip/api.py def close ( self , no_log = False ): \"\"\" Close the connection to the OCI-P server \"\"\" if self . authenticated and not no_log : self . logger . debug ( \"Disconnect by logging out\" ) self . send_command ( \"LogoutRequest\" , user_id = self . username , reason = \"Connection close\" , ) self . authenticated = False if self . socket : try : self . socket . shutdown ( socket . SHUT_RDWR ) self . socket . close () except OSError : pass # we just ignore this under these circumstances if not no_log : self . logger . info ( f \"Disconnected from host= { self . host } port= { self . port } \" ) self . socket = None","title":"close()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.command","text":"Send a command and parameters to the server, receive and decode a response :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: Object instance :raises: OCIErrorResponse :raises: OCIErrorResponse Source code in broadworks_ocip/api.py def command ( self , command , ** kwargs ): \"\"\" Send a command and parameters to the server, receive and decode a response :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: Object instance :raises: OCIErrorResponse :raises: OCIErrorResponse \"\"\" if not self . authenticated : self . connect () self . authenticate () self . send_command ( command , ** kwargs ) return self . receive_response ()","title":"command()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.configure_logger","text":"Create and configure a logging object Source code in broadworks_ocip/api.py def configure_logger ( self ): \"\"\" Create and configure a logging object \"\"\" logger = logging . getLogger ( __name__ ) logger . setLevel ( logging . WARNING ) console_handler = logging . StreamHandler ( sys . stdout ) console_handler . setLevel ( logging . WARNING ) logger . addHandler ( console_handler ) self . logger = logger","title":"configure_logger()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.connect","text":"Open the connection to the OCI-P server :raises: OSError :raises: socket.timeout Source code in broadworks_ocip/api.py def connect ( self ): \"\"\" Open the connection to the OCI-P server :raises: OSError :raises: socket.timeout \"\"\" self . logger . debug ( f \"Attempting connection host= { self . host } port= { self . port } \" ) try : address = ( self . host , self . port ) conn = socket . create_connection ( address = address , timeout = self . connect_timeout , ) self . socket = conn self . logger . info ( f \"Connected to host= { self . host } port= { self . port } \" ) except OSError as e : self . logger . error ( \"Connection failed\" ) raise e except socket . timeout as e : self . logger . error ( \"Connection timed out\" ) raise e","title":"connect()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.decode_xml","text":"Decode XML into an OCICommand based object instance :param xml:XML string :type command: str :rtype: Object instance Source code in broadworks_ocip/api.py def decode_xml ( self , xml ): \"\"\" Decode XML into an OCICommand based object instance :param xml:XML string :type command: str :rtype: Object instance \"\"\" root = etree . fromstring ( xml ) if root . tag != \" {C} BroadsoftDocument\" : raise ValueError self . logger . debug ( \"Decoding BroadsoftDocument\" ) for element in root : if element . tag == \"command\" : command = element . get ( \"{http://www.w3.org/2001/XMLSchema-instance}type\" ) self . logger . debug ( f \"Decoding command { command } \" ) cls = self . _despatch_table [ command ] result = cls . _build_from_etree ( element ) self . logger . info ( f \"<<< { result . _type } \" ) result . _post_xml_decode () return result","title":"decode_xml()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.get_command_object","text":"Build the OCICommand object instance for a command and parameter :param command: A single word name of a OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: Object instance Source code in broadworks_ocip/api.py def get_command_object ( self , command , ** kwargs ): \"\"\" Build the OCICommand object instance for a command and parameter :param command: A single word name of a OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: Object instance \"\"\" cls = self . get_type_class ( command ) cmd = cls ( session_id = self . session_id , ** kwargs ) return cmd","title":"get_command_object()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.get_command_xml","text":"Build the XML for a command and parameter :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: XML string Source code in broadworks_ocip/api.py def get_command_xml ( self , command , ** kwargs ): \"\"\" Build the XML for a command and parameter :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command :rtype: XML string \"\"\" cmd = self . get_command_object ( command , ** kwargs ) return cmd . _build_xml ()","title":"get_command_xml()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.get_type_class","text":"Given a name (Request/Response/Type) name, return a class object for it :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :rtype: class object :raises: KeyError Source code in broadworks_ocip/api.py def get_type_class ( self , command ): \"\"\" Given a name (Request/Response/Type) name, return a class object for it :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :rtype: class object :raises: KeyError \"\"\" try : cls = self . _despatch_table [ command ] except KeyError as e : self . logger . error ( f \"Unknown command requested - { command } \" ) raise e return cls","title":"get_type_class()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.get_type_object","text":"Build the OCIType object instance for a type and parameters :param command: A single word name of a OCIType() :type command: str :param kwargs: The parameters for the command :rtype: Object instance Source code in broadworks_ocip/api.py def get_type_object ( self , command , ** kwargs ): \"\"\" Build the OCIType object instance for a type and parameters :param command: A single word name of a OCIType() :type command: str :param kwargs: The parameters for the command :rtype: Object instance \"\"\" cls = self . get_type_class ( command ) cmd = cls ( ** kwargs ) return cmd","title":"get_type_object()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.on_init","text":"Initialise the API object Source code in broadworks_ocip/api.py def on_init ( self ): \"\"\" Initialise the API object \"\"\" if self . session_id is None : self . session_id = str ( uuid . uuid4 ()) if self . logger is None : self . configure_logger () self . build_despatch_table () self . authenticated = False","title":"on_init()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.receive_response","text":"Wait and receive response XML from server, and decode it :rtype: Object instance :raises: OCIErrorTimeOut Source code in broadworks_ocip/api.py def receive_response ( self ): \"\"\" Wait and receive response XML from server, and decode it :rtype: Object instance :raises: OCIErrorTimeOut \"\"\" content = b \"\" while True : readable , writable , exceptional = select . select ( [ self . socket ], [], [], self . command_timeout , ) if readable : # there is only one thing in the set... content += self . socket . recv ( 4096 ) # look for the end of document marker (we ignore line ends) splits = content . partition ( b \"</BroadsoftDocument>\" ) if len ( splits [ 1 ]) > 0 : break elif not readable and not writable and not exceptional : raise OCIErrorTimeOut ( object = self , message = \"Read timeout\" ) self . logger . log ( VERBOSE_DEBUG , f \"RECV: { str ( content ) } \" ) return self . decode_xml ( content )","title":"receive_response()"},{"location":"library/#broadworks_ocip.api.BroadworksAPI.send_command","text":"Build the XML for a command and parameter and send it to the server :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command Source code in broadworks_ocip/api.py def send_command ( self , command , ** kwargs ): \"\"\" Build the XML for a command and parameter and send it to the server :param command: A single word name of a OCIType(),OCIRequest(),OCIResponse() :type command: str :param kwargs: The parameters for the command \"\"\" self . logger . info ( f \">>> { command } \" ) xml = self . get_command_xml ( command , ** kwargs ) self . logger . log ( VERBOSE_DEBUG , f \"SEND: { str ( xml ) } \" ) self . socket . sendall ( xml + b \" \\n \" )","title":"send_command()"},{"location":"license/","text":"BSD License Copyright (c) 2020, Nigel Metheringham All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"usage/","text":"Usage Simple Usage To use Broadworks OCI-P Interface in a project:- from broadworks_ocip import BroadworksAPI # configure the API, connect and authenticate to the server api = BroadworksAPI ( host = args . host , port = args . port , username = args . username , password = args . password , ) # get the platform software level response = api . command ( \"SystemSoftwareVersionGetRequest\" ) print ( response . version ) # get a list of Service Providers on the platform response = api . command ( \"ServiceProviderGetListRequest\" ) # the response table is provided as a list of named tuple entries for provider in response . service_provider_table : print ( provider . service_provider_id ) More Complex Usage Some commands are more complex and made up of additional type components. This could lead to commands such as this:: result = api . get_command_object ( \"GroupServiceModifyAuthorizationListRequest\" , service_provider_id = \"some_enterprise\" , group_id = \"somegroup\" , service_pack_authorization = [ # a list of ServicePackAuthorization objects api . get_type_object ( # authorized, no limits \"ServicePackAuthorization\" , service_pack_name = \"Voicemail\" , authorized_quantity = api . get_type_object ( \"UnboundedPositiveInt\" , unlimited = True , ), ), api . get_type_object ( # authorized, limited to 32 instances \"ServicePackAuthorization\" , service_pack_name = \"Hushmail\" , authorized_quantity = api . get_type_object ( \"UnboundedPositiveInt\" , quantity = 32 , ), ), api . get_type_object ( # de-authorized \"ServicePackAuthorization\" , service_pack_name = \"Phone\" , unauthorized = True , ), ], ) Failures and Exceptions A failed command typically returns an ErrorResponse . When decoded the ErrorResponse will raise a OCIErrorResponse exception. Additionally a command may raise other exceptions, related to the TCP communications layers, or a OCIErrorTimeOut if no response is received in reasonable time. Server Due to the way these objects have been built it should be fairly simple to make a Broadworks OCI-P server which accepts and decodes requests and replies with appropriate responses; and this was done in a very simplified form to make the fakeserver.py which is used in testing. However this is not likely to be very useful in practice.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#simple-usage","text":"To use Broadworks OCI-P Interface in a project:- from broadworks_ocip import BroadworksAPI # configure the API, connect and authenticate to the server api = BroadworksAPI ( host = args . host , port = args . port , username = args . username , password = args . password , ) # get the platform software level response = api . command ( \"SystemSoftwareVersionGetRequest\" ) print ( response . version ) # get a list of Service Providers on the platform response = api . command ( \"ServiceProviderGetListRequest\" ) # the response table is provided as a list of named tuple entries for provider in response . service_provider_table : print ( provider . service_provider_id )","title":"Simple Usage"},{"location":"usage/#more-complex-usage","text":"Some commands are more complex and made up of additional type components. This could lead to commands such as this:: result = api . get_command_object ( \"GroupServiceModifyAuthorizationListRequest\" , service_provider_id = \"some_enterprise\" , group_id = \"somegroup\" , service_pack_authorization = [ # a list of ServicePackAuthorization objects api . get_type_object ( # authorized, no limits \"ServicePackAuthorization\" , service_pack_name = \"Voicemail\" , authorized_quantity = api . get_type_object ( \"UnboundedPositiveInt\" , unlimited = True , ), ), api . get_type_object ( # authorized, limited to 32 instances \"ServicePackAuthorization\" , service_pack_name = \"Hushmail\" , authorized_quantity = api . get_type_object ( \"UnboundedPositiveInt\" , quantity = 32 , ), ), api . get_type_object ( # de-authorized \"ServicePackAuthorization\" , service_pack_name = \"Phone\" , unauthorized = True , ), ], )","title":"More Complex Usage"},{"location":"usage/#failures-and-exceptions","text":"A failed command typically returns an ErrorResponse . When decoded the ErrorResponse will raise a OCIErrorResponse exception. Additionally a command may raise other exceptions, related to the TCP communications layers, or a OCIErrorTimeOut if no response is received in reasonable time.","title":"Failures and Exceptions"},{"location":"usage/#server","text":"Due to the way these objects have been built it should be fairly simple to make a Broadworks OCI-P server which accepts and decodes requests and replies with appropriate responses; and this was done in a very simplified form to make the fakeserver.py which is used in testing. However this is not likely to be very useful in practice.","title":"Server"}]}